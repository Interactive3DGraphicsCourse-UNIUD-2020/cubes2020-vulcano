<html>
	<head>
		<title>Starting Code for 1st Project 2017 - with lights and textures</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
  			background-image: linear-gradient(#353678, #fff0ad, #fff761);
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		var cube_pivot;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true, alpha:true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( "#7f0996", 0.3 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(0,7,25);
			camera.lookAt( new THREE.Vector3(0,0,0));

			var loader = new THREE.ObjectLoader();
			var skullIsland; //variabile a cui assegnare modello dell'isola
			loader.load(
				//path del modello da caricare
				"models/isola.json",

				//onLoad callback
				function ( obj ) {
					skullIsland = obj;
		
					skullIsland.position.y = 3;
					skullIsland.rotation.y = -90 * Math.PI/180;
					skullIsland.castShadow = true;
					skullIsland.receiveShadow = true;

					scene.add( obj );
				},

				//onProgress callback
				function ( xhr ) {
					console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				},

				//onError callback
				function ( err ) {
					console.error( 'An error happened' );
				}
			);
			
			//ALTRI OGGETTI

			//cube pivot
			cube_pivot = new THREE.Object3D();
			cube_pivot.matrix.makeTranslation(0,2,0);
			var cube_pivotRotMatrix = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), 8*Math.PI/180);
			cube_pivot.matrix.multiplyMatrices ( cube_pivot.matrix, cube_pivotRotMatrix); 

			cube_pivot.matrixAutoUpdate = false;
			scene.add(cube_pivot);

			//cube
			var cube_geometry = new THREE.BoxGeometry(1,1,1);
			var cube_texture = new THREE.TextureLoader().load('textures/stone.jpg');
			var cube_material = new THREE.MeshPhongMaterial( { bumpMap: cube_texture, bumpScale: 0.04 } );
			var cube = new THREE.Mesh( cube_geometry, cube_material );
			cube.castShadow = true;
			cube.receiveShadow = true;

			cube.matrix.makeTranslation(13,0,0);
            var cubeScaleMatrix = new THREE.Matrix4().makeScale(1.7,1,1.7);
			cube.matrix.multiplyMatrices ( cube.matrix, cubeScaleMatrix); //scalo cubo

			cube.matrixAutoUpdate = false;

			cube_pivot.add(cube);

			//aggiungo altro cubo da attaccare al primo
			var cube_bottom = new THREE.Mesh( cube_geometry, cube_material );
			cube_bottom.castShadow = true;
			cube_bottom.receiveShadow = true;

			cube_bottom.matrix.makeTranslation(13,-0.5,0);
            var cubeScaleMatrix2 = new THREE.Matrix4().makeScale(1,0.5,1);
			cube_bottom.matrix.multiplyMatrices ( cube_bottom.matrix, cubeScaleMatrix2); //scalo cubo

			cube_bottom.matrixAutoUpdate = false;
			cube_pivot.add(cube_bottom);


			//LUCI
			hemiLight = new THREE.HemisphereLight( "#f0c9f5", "#353678", 0.3 );
			hemiLight.position.set( -100, -500, 100 );
			scene.add( hemiLight );

			dirLight = new THREE.DirectionalLight( "#fff7d4", 0.4 );
			dirLight.position.set( -1, -8, 6 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			
			//STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			

			// uncomment if you need to draw coordinate axes when building the scene
			//Coordinates.drawAllAxes();
			
			//CONTROLS
			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );
			
			
		}
		
		function Update() {
			requestAnimationFrame( Update );

			cube_pivot.matrix.multiplyMatrices ( cube_pivot.matrix, new THREE.Matrix4().makeRotationY(0.005) );

			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>